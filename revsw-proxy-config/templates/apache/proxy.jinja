{% import "common/ssl.jinja" as ssl_mod %}
{% import "common/third_party.jinja" as third_party_mod %}
{% import "common/loop_detect.jinja" as loop_detect_mod %}

# Brunko: test
{% macro _common_profiles_and_security(this, co_profiles_mod, co_profiles) %}
    # Start rules from scratch
    RevProfilesFlushSelectionRules

    # Run customized profile selection algo
{{  co_profiles_mod.profile_selection(co_profiles) }}

    # Security setup
{%  if this.SECURITY_MODE == "on" %}
    SecRuleEngine On
{%  elif this.SECURITY_MODE == "detect" %}
    SecRuleEngine DetectionOnly
{%  else %}
    SecRuleEngine Off
{%  endif %}
    SecAuditLogStorageDir /var/cache/modsecurity/audit/{{this.SERVER_NAME}}/
    SecAuditLog "/var/cache/modsecurity/audit/{{this.SERVER_NAME}}.index"
    SecAuditLogType Concurrent

{%  set geoip_enabled = this.ENABLE_VARNISH_GEOIP_HEADERS %}
{%  if this.acl.enabled %}
    # Begin ACLs
{%      if this.acl.acl_rules %}
{%          if this.acl.action == "allow_except" %}
{%              set outer_directive = "RequireAll" %}
{%              set inner_directive = "RequireNone" %}
{%          else %}{# deny all #}
{%              set outer_directive = "RequireAny" %}
{%              set inner_directive = "RequireAny" %}
{%          endif %}{# allow all #}
{%          set countries = this.acl.acl_rules|selectattr("country_code")|list %}
{%          if countries|length %}{# use GeoIP #}
{%              set geoip_enabled = True %}
    SetEnvIf MM_COUNTRY_CODE ^({{ countries|map(attribute="country_code")|join("|") }}) IsAclCountry
{%          endif %}{# use GeoIP #}

    <Location / >
        <{{outer_directive}}>
            Require all {{ "granted" if this.acl.action == "allow_except" else "denied" }}
            <{{inner_directive}}>
{%          for rule in this.acl.acl_rules %}
{%              if rule.host_name|is_ipv4 %}
                Require ip {{rule.host_name}}{{ "/" + rule.subnet_mask if rule.subnet_mask else "" }}
{%              elif rule.host_name %}
                Require host {{rule.host_name}}
{%              endif %}
{%              if rule.header_name %}
                Require expr %{HTTP:{{rule.header_name}}} == "{{rule.header_value}}"
{%              endif %}
{%          endfor %}{# rule in this.acl.acl_rules #}
{%          if countries|length %}{# use GeoIP #}
                Require env IsAclCountry
{%          endif %}
            </{{inner_directive}}>
        </{{outer_directive}}>
    </Location>
{%      elif this.acl.action == "deny_except" %}{# not this.acl.acl_rules #}
    <Location / >
        Require all denied
    </Location>
{%      endif %}{# this.acl.acl_rules #}
    # End ACLs
{%  endif %}{# this.acl.enabled #}

{%  if geoip_enabled %}
    # GeoIP setup
    MaxMindDBEnable On
    MaxMindDBFile MM_CITY_DB /opt/revsw-config/apache/GeoLite2-City.mmdb
    MaxMindDBEnv MM_COUNTRY_CODE MM_CITY_DB/country/iso_code

{%      if this.ENABLE_VARNISH_GEOIP_HEADERS %}
    MaxMindDBEnv MM_COUNTRY_NAME MM_CITY_DB/country/names/en
    MaxMindDBEnv MM_CONTINENT_CODE MM_CITY_DB/continent/code
    MaxMindDBEnv MM_CITY_NAME MM_CITY_DB/city/names/en
    MaxMindDBEnv MM_LONGITUDE MM_CITY_DB/location/longitude
    MaxMindDBEnv MM_LATITUDE MM_CITY_DB/location/latitude
    RequestHeader set X-Rev-ContinentCode "%{MM_CONTINENT_CODE}e"
    RequestHeader set X-Rev-CountryCode "%{MM_COUNTRY_CODE}e"
    RequestHeader set X-Rev-CountryName "%{MM_COUNTRY_NAME}e"
    RequestHeader set X-Rev-CityName "%{MM_CITY_NAME}e"
    RequestHeader set X-Rev-Longitude "%{MM_LONGITUDE}e"
    RequestHeader set X-Rev-Latitude "%{MM_LATITUDE}e"
    RequestHeader set X-Rev-Node "{{HOSTNAME_SHORT}}"
{%      endif %}{# this.ENABLE_VARNISH_GEOIP_HEADERS #}
{%      if this.DEBUG_MODE %}
    Header set X-Rev-CountryCode "%{MM_COUNTRY_CODE}e"
    Header set X-Rev-CountryName "%{MM_COUNTRY_NAME}e"
    Header set X-Rev-CityName "%{MM_CITY_NAME}e"
    Header set X-Rev-Latitude "%{MM_LONGITUDE}e"
    Header set X-Rev-Longitude "%{MM_LATITUDE}e"
    Header set X-Rev-Node "{{HOSTNAME_SHORT}}"
{%      endif %}
    # End GeoIP setup
{%  endif %}{# geoip_enabled #}
{%- endmacro %}

{% macro _common_sharding(this) %}
{%  for shard in range(this.DOMAIN_SHARDS_COUNT) %}
    # Sharding alias
    ServerAlias s{{shard}}-{{this.SERVER_NAME}}
{%  endfor %}
{%- endmacro %}

{% macro _common_static_servers(this, servers, extra_servers, proto) %}
{%  for host in (servers|list + extra_servers|list)|flatten_to_set %}
{%      set url = proto + "://" + host %}
    <Location /rev-third-party-{{proto}}/{{host}}>
        ProxyPreserveHost Off
        RevProfilesMode Off
        ProxyPass {{url}} retry=0

{%      if this.ENABLE_HTML_SUBSTITUTE %}
        FilterDeclare decompress CONTENT_SET
        FilterProvider decompress INFLATE "%{CONTENT_TYPE} =~ m|^text/html| && %{REQUEST_METHOD} != 'HEAD'"

        FilterDeclare compress CONTENT_SET
        FilterProvider compress DEFLATE "%{CONTENT_TYPE} =~ m|^text/html| && %{REQUEST_METHOD} != 'HEAD'"

        FilterDeclare replace CONTENT_SET
        FilterProvider replace SUBSTITUTE "%{CONTENT_TYPE} =~ m|^text/html| && %{REQUEST_METHOD} != 'HEAD'"

        FilterChain =decompress replace compress

        # Make sure absolute URLs pointing to the origin go through us instead
        Substitute "s|([\"'])(https?:)?//{{this.ORIGIN_SERVER_NAME}}|$1|q"

{{          third_party_mod.replace_urls(this, proto, False)|indent }}
{%      endif %}
    </Location>
    ProxyPassReverse /rev-third-party-{{proto}}/{{host}} {{url}}
{%  endfor %}
{%- endmacro %}{# _common_static_servers #}

{% macro _common_co_balancer_config(this, balancer_name, routeid_suffix, profiles_base_port, content_optimizers) %}
    # mod_proxy and mod_proxy_balancer
    # Balancer members are reused immediately even if they have errors (retry=0),
    # to allow for DNS-based HA.
    # We try to maintain a connection to them for as long as possible (keepalive=On).
{%  set proxy_params = "retry=0 ttl=250" %}
{%  if content_optimizers|list|length == 1 %}
{%      set co_base_url = content_optimizers[0] %}
{%      set caller_params = proxy_params %}
{%  else %}
{%      set co_base_url = "balancer://" + balancer_name %}
{%      set caller_params = "" %}
    Header add Set-Cookie "ROUTEID{{routeid_suffix}}=.%{BALANCER_WORKER_ROUTE}e; path=/" env=BALANCER_ROUTE_CHANGED
    <Proxy balancer://{{balancer_name}}>
{%      set route_no = 1 %}
{%      for co in content_optimizers %}
        BalancerMember {{co}} route={{route_no}} keepalive=On {{proxy_params}}
{%          set route_no = route_no + 1 %}
{%      endfor %}
        ProxySet stickysession=ROUTEID{{routeid_suffix}}
    </Proxy>
{%  endif %}

    # Wait at most for configured seconds for a reply from CO, then return error message.
    # This will make recovery from CO failure quicker.
    # The DNS monitor will assign another CO to the same domain name.
    ProxyTimeout {{this.PROXY_TIMEOUT}}

    # mod_rev_profile_selection
    ProxyConnPoolCount {{this.REV_PROFILES_COUNT}}
    RevProfilesBasePort {{profiles_base_port}}
{{  caller(co_base_url, caller_params) }}
{%- endmacro %}{# _common_co_balancer_config #}

{% macro _common_proxy_config_step1(this, co_profiles_mod, co_profiles, varnish_port, profiles_base_port, content_optimizers) %}
    ServerName {{this.SERVER_NAME}}
{{  _common_sharding(this) }}

{%  if this.DEBUG_MODE %}
    LogLevel trace6
{%  endif %}

{{  loop_detect_mod.loop_detect(this) }}

    # mod_status (debug)
    <Location /rev-status>
        SetHandler server-status
        Require local
    </Location>
    # Don't pass /rev-status through proxy
    ProxyPass /rev-status !

    # Never disable the Varnish backend, even if it has temporary problems.
    ProxyPass / http://127.0.0.1:{{varnish_port}}/ retry=0
    ProxyPassReverse / http://127.0.0.1:{{varnish_port}}/
    ProxyPreserveHost On

    # mod_rev_profile_selection
    RevProfilesMode varnish_step1

{{  _common_profiles_and_security(this, co_profiles_mod, co_profiles) }}

{%  if this.BYPASS_VARNISH_LOCATIONS %}
    # Bypass Varnish for certain URLs

    # First set up CO balancer
{%      call (co_base_url, proxy_params) _common_co_balancer_config(this, "bp_cos_bypass", "B", profiles_base_port, content_optimizers) %}
{%          for url in this.BYPASS_VARNISH_LOCATIONS %}
{%              set rel_url = url if url[0] != "/" else url[1:] %}
    <Location /{{rel_url}}>
        ProxyPass {{co_base_url}}/{{rel_url}} {{proxy_params}}
        ProxyPassReverse {{co_base_url}}/{{rel_url}}
        ProxyPreserveHost On
        RevProfilesMode full
    </Location>
    ProxyPass /{{rel_url}} !
{%          endfor %}
{%      endcall %}
    # End Varnish bypass
{%  endif %}{# this.BYPASS_VARNISH_LOCATIONS #}
{% endmacro %}{# _common_proxy_config_step1 #}

{% macro _common_proxy_config_step2(this, co_profiles_mod, co_profiles, profiles_base_port, content_optimizers, is_https) %}
    ServerName {{this.SERVER_NAME}}

{%  if this.DEBUG_MODE %}
    LogLevel trace6
{%  endif %}

{%  if not this.ENABLE_VARNISH %}
{{      _common_sharding(this) }}
{{      loop_detect_mod.loop_detect(this) }}
{%  endif %}

    # mod_status (debug)
    <Location /rev-status>
        SetHandler server-status
        Require local
    </Location>
    # Don't pass /rev-status through proxy
    ProxyPass /rev-status !

{%  if this.BLOCK_CRAWLERS %}
    # Don't allow creepy crawlers (Googlebot etc) on our site
    Alias /robots.txt /var/www/robots.txt
    ProxyPass /robots.txt !
{%  endif %}

    <Location /rev-diablo>
        ProxyPreserveHost Off
        RevProfilesMode Off
{%  if this.ENABLE_JS_SUBSTITUTE %}
        RevJSSubstituteEnabled Off
{%  endif %}
        ProxyPass http://rev-js-source.revdn.net retry=0
        ProxyPassReverse http://rev-js-source.revdn.net
    </Location>

{%  if this.ENABLE_JS_SUBSTITUTE %}
    # Rev JS substitute and accompanying script
    RevJSSubstituteEnabled On
    Alias /rev-js /usr/share/revsw-libapache2-mod-rev-js-substitute
    ProxyPass /rev-js !
    <Directory /usr/share/revsw-libapache2-mod-rev-js-substitute>
        RevJSSubstituteEnabled Off
        Require all granted
    </Directory>
{%  endif %}{# ENABLE_JS_SUBSTITUTE #}

{%  call (co_base_url, proxy_params) _common_co_balancer_config(this, "bp_cos", "", profiles_base_port, content_optimizers) %}
    ProxyPass / {{co_base_url}}/ {{proxy_params}}
    ProxyPassReverse / {{co_base_url}}/
    ProxyPassReverse / http://{{this.SERVER_NAME}}/
    ProxyPreserveHost On
{%  endcall %}

{%  if this.BYPASS_CO_LOCATIONS %}
    # Bypass CO for certain URLs
{%      set origins = this.ORIGIN_SERVERS_HTTPS if is_https else this.ORIGIN_SERVERS_HTTP %}
{%      set proxy_params = "keepalive=On" + (" ttl=" + this.ORIGIN_IDLE_TIMEOUT|string if this.ORIGIN_IDLE_TIMEOUT and this.ORIGIN_REUSE_CONNS else "") + (" disablereuse=On" if not this.ORIGIN_REUSE_CONNS else "") %}
{%      if origins|length > 1 %}
    # First set up origin balancer
    <Proxy balancer://bp_ows>
{%          set route_no = 1 %}
{%          for ows in origins %}
        BalancerMember {{ows}} route={{route_no}} {{proxy_params}}
{%              set route_no = route_no + 1 %}
{%          endfor %}
        ProxySet stickysession=ROUTEID
    </Proxy>
{%      endif %}

{%      for url in this.BYPASS_CO_LOCATIONS %}
{%          set rel_url = url if url[0] != "/" else url[1:] %}
    <Location /{{rel_url}} >
{%          if origins|length == 1 %}
        ProxyPass {{origins[0]}}/{{rel_url}} retry=0 {{proxy_params}}
        ProxyPassReverse {{origins[0]}}/{{rel_url}}
{%          else %}{# origins|length != 1 #}
        ProxyPass balancer://bp_ows/{{rel_url}}
        ProxyPassReverse balancer://bp_ows/{{rel_url}}
{%          endif %}{# origins|length #}
        RevProfilesMode off
        # Make sure the origin sees the right Host header
        ProxyPreserveHost On
        ProxySSLHostname {{this.ORIGIN_SERVER_NAME}}
        RequestHeader set Host {{this.ORIGIN_SERVER_NAME}}
    </Location>
    ProxyPass /{{rel_url}} !
{%      endfor %}{# url in this.BYPASS_CO_LOCATIONS #}
    # End CO bypass
{%  endif %}{# this.BYPASS_CO_LOCATIONS #}

{%  if this.ENABLE_VARNISH %}
    RevProfilesMode varnish_step2
{%  else %}
    RevProfilesMode full

{{  _common_profiles_and_security(this, co_profiles_mod, co_profiles) }}
{%  endif %}
{%- endmacro %}{# _common_proxy_config_step2 #}

{% macro _common_frontend(this) %}
    # Optional user customizations in BP frontend
{{  this.CUSTOM_WEBSERVER_CODE_BEFORE|extract_custom_webserver_code("APACHE") }}
    # End optional user customizations in BP frontend
{%- endmacro %}{# _common_frontend #}

{% macro setup(this, co_profiles_mod, co_profiles) %}

{%  if this.SECURITY_MODE != "block" %}{# "block" means "block site", so we simply remove the site from Apache #}

{%      if this.ENABLE_HTTP %}
<VirtualHost *:80>
{%          if this.ENABLE_VARNISH %}
{{              _common_proxy_config_step1(this, co_profiles_mod, co_profiles, 8080, this.REV_PROFILES_BASE_PORT_HTTP, this.CONTENT_OPTIMIZERS_HTTP) }}
{{              _common_frontend(this) }}
</VirtualHost>

<VirtualHost 127.0.0.1:9080>
    # Don't log accesses on this vhost; they all come from localhost
    CustomLog /dev/null revsw

    # Make sure the connections between Varnish and BP are kept alive for 10 minutes
    KeepAliveTimeout 600

    # Don't add X-Forwarded-For in this step, it's already added in step1
    ProxyAddHeaders Off
{%          else %}{# not this.ENABLE_VARNISH #}
{{              _common_frontend(this) }}
{%          endif %}{# this.ENABLE_VARNISH #}

{%          if this.DOMAINS_TO_PROXY_HTTPS %}
    # Must enable SSL proxy support for HTTPS static content servers
{{              ssl_mod.setup_proxy_only(this.ssl) }}
{%          endif %}

    # Optional customizations before generic BP config
{{          caller(True) }}
    # End optional customizations before generic BP config

{% set extra_domains_http = this.DOMAINS_TO_OPTIMIZE_HTTP if this.ENABLE_JS_SUBSTITUTE else [] %}
{% set extra_domains_https = this.DOMAINS_TO_OPTIMIZE_HTTPS if this.ENABLE_JS_SUBSTITUTE else [] %}

    # HTTP static content servers
{{          _common_static_servers(this, this.DOMAINS_TO_PROXY_HTTP, extra_domains_http, "http") }}

{%          if not this.ENABLE_HTTPS %}
    # HTTPS static content servers
{{              _common_static_servers(this, this.DOMAINS_TO_PROXY_HTTPS, extra_domains_https, "https") }}
{%          endif %}

{{          _common_proxy_config_step2(this, co_profiles_mod, co_profiles, this.REV_PROFILES_BASE_PORT_HTTP, this.CONTENT_OPTIMIZERS_HTTP, false) }}

    # Optional customizations after generic BP config
{{          caller(False) }}
{{          this.CUSTOM_WEBSERVER_CODE_AFTER|extract_custom_webserver_code("APACHE") }}
    # End optional customizations after generic BP config
</VirtualHost>
{%      endif %}{# this.ENABLE_HTTP #}

{%      if this.ENABLE_HTTPS %}
<VirtualHost *:443>
{%          if this.ENABLE_VARNISH and not this.BYPASS_VARNISH_LOCATIONS %}
{{              ssl_mod.setup_no_proxy(this.ssl) }}
{%          else %}{# If this.BYPASS_VARNISH_LOCATIONS is true, we need SSL proxy support for direct connections to CO #}
{{              ssl_mod.setup(this.ssl) }}
{%          endif %}

    # OCSP stapling is only enabled on the BP
    SSLUseStapling on
    SSLStaplingResponderTimeout 5
    SSLStaplingReturnResponderErrors off

    # mod_spdy
    SpdyEnabled {{ "On" if this.ENABLE_SPDY else "Off" }}

{%          if this.ENABLE_VARNISH %}
{{              _common_proxy_config_step1(this, co_profiles_mod, co_profiles, 8443, this.REV_PROFILES_BASE_PORT_HTTPS, this.CONTENT_OPTIMIZERS_HTTPS) }}
{{              _common_frontend(this) }}
</VirtualHost>

<VirtualHost 127.0.0.1:9443>
{{              ssl_mod.setup_proxy_only(this.ssl) }}

    # Don't log accesses on this vhost; they all come from localhost
    CustomLog /dev/null revsw

    # Make sure the connections between Varnish and BP are kept alive for 10 minutes
    KeepAliveTimeout 600

    # Don't add X-Forwarded-For in this step, it's already added in step1
    ProxyAddHeaders Off
{%          else %}{# not this.ENABLE_VARNISH #}
{{              _common_frontend(this) }}
{%          endif %}{# this.ENABLE_VARNISH #}
    # Optional customizations before generic BP config
{{          caller(True) }}
    # End optional customizations before generic BP config

{%          set extra_domains_http = this.DOMAINS_TO_OPTIMIZE_HTTP if this.ENABLE_JS_SUBSTITUTE else [] %}
{%          set extra_domains_https = this.DOMAINS_TO_OPTIMIZE_HTTPS if this.ENABLE_JS_SUBSTITUTE else [] %}

    # HTTP static content servers
{{          _common_static_servers(this, this.DOMAINS_TO_PROXY_HTTP, extra_domains_http, "http") }}

    # HTTPS static content servers
{{          _common_static_servers(this, this.DOMAINS_TO_PROXY_HTTPS, extra_domains_https, "https") }}

{{          _common_proxy_config_step2(this, co_profiles_mod, co_profiles, this.REV_PROFILES_BASE_PORT_HTTPS, this.CONTENT_OPTIMIZERS_HTTPS, true) }}

    # mod_pagespeed in CO looks at this header when optimizing for SPDY
    RequestHeader add X-PSA-Optimize-For-SPDY On

    # Optional customizations after generic BP config
{{          caller(False) }}
{{          this.CUSTOM_WEBSERVER_CODE_AFTER|extract_custom_webserver_code("APACHE") }}
    # End optional customizations after generic BP config
</VirtualHost>
{%      endif %}{# this.ENABLE_HTTPS #}

{%  else %}{# this.SECURITY_MODE == "block", which means "block access for everybody" #}

{%      if this.ENABLE_HTTP %}
<VirtualHost *:80>
    ServerName {{this.SERVER_NAME}}
    <Location / >
        Require all denied
    </Location>
</VirtualHost>
{%      endif %}{# this.ENABLE_HTTP #}
{%      if this.ENABLE_HTTPS %}
<VirtualHost *:443>
    ServerName {{this.SERVER_NAME}}
{{          ssl_mod.setup_no_proxy(this.ssl) }}
    <Location / >
        Require all denied
    </Location>
</VirtualHost>
{%      endif %}{# this.ENABLE_HTTPS #}

{%  endif %}{# this.SECURITY_MODE != "block" #}

{%- endmacro %}


{% macro _co_profile_factory(co_profiles_mod, co_profiles, index) -%}
{% 		if index == 0 -%}
{{ 			co_profiles_mod.profile0(co_profiles) }}
{%  	elif index == 1 -%}
{{     		co_profiles_mod.profile1(co_profiles) }}
{%  	elif index == 2 -%}
{{     		co_profiles_mod.profile2(co_profiles) }}
{%  	elif index == 3 -%}
{{     		co_profiles_mod.profile3(co_profiles) }}
{%  	elif index == 4 -%}
{{     		co_profiles_mod.profile4(co_profiles) }}
{%  	else %}
	# PROFILE OUT OF RANGE - using profile #0
{{ 			co_profiles_mod.profile0(co_profiles) }}
{%  	endif %}
{%- endmacro %}

{% macro setup(this, co_profiles_mod, co_profiles) -%}
{% 		set is_https = False %}
{% 		set enable_pagespeed = this.ENABLE_OPTIMIZATION and co_profiles.REV_OPTIMIZATION_LEVEL|default("none") != "none" %}
{% 		for enable in (this.ENABLE_HTTP, this.ENABLE_HTTPS) %}
{% 			if enable %}
{% 				for p in range(this.REV_PROFILES_COUNT) %}
# Profile #{{p}}
{% 					set profile_port = (this.REV_PROFILES_BASE_PORT_HTTPS if is_https else this.REV_PROFILES_BASE_PORT_HTTP) + p %}
{% 					set proto = "https" if is_https else "http" %}
{% 					if (this.LISTEN_REV_PROFILES_BASE_PORT_HTTPS if is_https else this.LISTEN_REV_PROFILES_BASE_PORT_HTTP) %}
Listen {{profile_port}}
{% 					endif %}
<VirtualHost *:{{profile_port}}>
    ServerName {{this.SERVER_NAME}}
{% 					for shard in range(this.DOMAIN_SHARDS_COUNT) %}
    # Sharding alias
    ServerAlias s{{shard}}-{{this.SERVER_NAME}}
{% 					endfor %}

{% 					if this.DEBUG_MODE %}
    LogLevel trace6
{% 					endif %}

{{ 					loop_detect_mod.loop_detect(this) }}

    # Optional customizations before generic options
{{ 					caller(True, is_https) }}
    # End optional customizations before generic options

{% 					if is_https %}
{{  					ssl_mod.setup_bp_co(this.ssl) }}
{% 					elif this.ORIGIN_SERVERS_HTTPS %}
    # Must enable SSL proxy support for HTTPS origin servers
{{  					ssl_mod.setup_proxy_only(this.ssl) }}
{% 					endif %}

    # For RUM/Boomerang data and URL substitutions
{% 					if enable_pagespeed %}
    AddOutputFilterByType SUBSTITUTE text/html
{% 					else %}
    FilterDeclare decompress CONTENT_SET
    FilterProvider decompress INFLATE "%{CONTENT_TYPE} =~ m|^text/html| && %{REQUEST_METHOD} != 'HEAD'"

    FilterDeclare compress CONTENT_SET
    FilterProvider compress DEFLATE "%{CONTENT_TYPE} =~ m|^text/html| && %{REQUEST_METHOD} != 'HEAD'"

    FilterDeclare replace CONTENT_SET
    FilterProvider replace SUBSTITUTE "%{CONTENT_TYPE} =~ m|^text/html| && %{REQUEST_METHOD} != 'HEAD'"

    FilterChain =decompress replace compress
{% 					endif %}

{% 					set origins = this.ORIGIN_SERVERS_HTTPS if is_https else this.ORIGIN_SERVERS_HTTP %}
    # Wait at most for this many seconds for reply from Origin, then return error message.
    ProxyTimeout {{this.PROXY_TIMEOUT}}

{%                  set proxy_params = "keepalive=On" + (" ttl=" + this.ORIGIN_IDLE_TIMEOUT|string if this.ORIGIN_IDLE_TIMEOUT and this.ORIGIN_REUSE_CONNS else "") + (" disablereuse=On" if not this.ORIGIN_REUSE_CONNS else "") %}
{% 					if origins|length == 1 %}
    ProxyPass / {{origins[0]}}/ retry=0 {{proxy_params}}
    ProxyPassReverse / {{origins[0]}}/
{% 					else %}{# origins|length == 1 #}
    <Proxy balancer://co_ows>
{% 						set route_no = 1 %}
{% 						for ows in origins %}
        BalancerMember {{ows}} route={{route_no}} {{proxy_params}}
{% 							set route_no = route_no + 1 %}
{% 						endfor %}
        ProxySet stickysession=ROUTEID
    </Proxy>
    ProxyPass / balancer://co_ows/
    ProxyPassReverse / balancer://co_ows/
{% 					endif %}
    # Don't add X-Forwarded-For here, already added by BP
    ProxyAddHeaders Off
    # Make sure the origin sees the right Host header
    ProxyPreserveHost On
    ProxySSLHostname {{this.ORIGIN_SERVER_NAME}}
    RequestHeader set Host {{this.ORIGIN_SERVER_NAME}}

{% 					if enable_pagespeed %}
    # Resources from these domains are candidates for optimization
    ModPagespeedDomain {{this.SERVER_NAME}}
    ModPagespeedMapOriginDomain {{proto}}://127.0.0.1:{{profile_port}} {{proto}}://{{this.SERVER_NAME}}
{% 						for ows in origins %}
{% 							set host = ows|replace("://","-")|replace(":","-")|replace("/","-") %}
    ModPagespeedMapProxyDomain {{proto}}://{{this.SERVER_NAME}}/rev-ps-{{host}} {{ows}}
{% 						endfor %}

    # Faster locking means faster response time, see:
    # http://www.webperformance.com/load-testing/blog/2012/12/google-pagespeed-performance-with-memory-locking/
    ModPagespeedSharedMemoryLocks On

    # Allow cacheable, but modified HTML to be cached by Varnish
    # See: https://developers.google.com/speed/pagespeed/module/downstream-caching
    ModPagespeedDownstreamCachePurgeLocationPrefix {{proto}}://{{this.SERVER_NAME}}
    ModPagespeedDownstreamCachePurgeMethod PURGE
    ModPagespeedDownstreamCacheRewrittenPercentageThreshold 95

    # Disable all filters and start from scratch
    ModPagespeedRewriteLevel PassThrough

{% 						if this.DOMAIN_SHARDS_COUNT %}
    # Apply domain mapping rules to all resources, even if not optimized by PS, to shard everything
    ModPagespeedEnableFilters rewrite_domains
    ModPagespeedShardDomain {{this.SERVER_NAME}} {% for shard in range(this.DOMAIN_SHARDS_COUNT) %}s{{shard}}-{{this.SERVER_NAME}},{% endfor %}
{% 						endif %}

{% 						if this.ENABLE_OPTIMIZATION %}
    # Allow optimization of JS-referenced resources
    ModPagespeedInPlaceResourceOptimization on

    # Turn on browser-specific optimizations
    ModPagespeedEnableFilters in_place_optimize_for_browser

    # Customer profile settings
{{ 							_co_profile_factory(co_profiles_mod, co_profiles, p) }}
{% 						endif %}
{% 					else %}{# enable_pagespeed #}
    # Disable pagespeed
    ModPagespeed Off
{% 					endif %}{# enable_pagespeed #}

    # Optional customizations after generic options
{{ 					caller(False, is_https) }}
{{ 					this.CUSTOM_APACHE_CODE_AFTER }}
    # End optional customizations after generic options

{%                  if this.SERVER_NAME != this.ORIGIN_SERVER_NAME %}
    # Make sure absolute URLs pointing to the origin go through us instead
{%                      if (this.ENABLE_HTTP and this.ENABLE_HTTPS) and not is_https %}{# both supported; must prevent conversion from secure to unsecure #}
    # HTTPS links are turned into absolute ones to our own server
    Substitute "s|([\"'])https://{{this.ORIGIN_SERVER_NAME}}|$1https://{{this.SERVER_NAME}}|q"
    # HTTP links are turned into relative ones
    Substitute "s|([\"'])(http:)?//{{this.ORIGIN_SERVER_NAME}}|$1|q"
{%                      else %}{# only HTTP or only HTTPS #}
    Substitute "s|([\"'])(https?:)?//{{this.ORIGIN_SERVER_NAME}}|$1|q"
{%                      endif %}{# HTTP and/or HTTPS #}
{%                  endif %}{# this.SERVER_NAME != this.ORIGIN_SERVER_NAME #}

{{ 					third_party_mod.replace_urls(this, proto, this.ENABLE_OPTIMIZATION) }}

{%      			if this.REV_RUM_BEACON_URL %}
{%          			set rum_beacon_url = this.REV_RUM_BEACON_URL if this.REV_RUM_BEACON_URL|truncate(4,True,"") == "http" else proto + "://" + this.REV_RUM_BEACON_URL %}
    # RUM beacon
    Substitute "s|</head>|<script src='/rev-diablo/js/boomerang-rev.min.js'></script><script>BOOMR.init({RT:{cookie:'REV-RT', strict_referrer: false}, beacon_url: '{{rum_beacon_url}}'}); BOOMR.addVar('user_ip', '%{HTTP_X_FORWARDED_FOR}');</script></head>|q"

    ModPagespeedDisallow "{{proto}}://{{this.SERVER_NAME}}/rev-diablo/*"
{%      			endif %}
</VirtualHost>
{% 				endfor %}
{% 			endif %}
{% 			set is_https = True %}
{% 		endfor %}
{%- endmacro %}